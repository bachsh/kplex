__author__ = 'aaminov'


import networkx as nx
import matplotlib.pyplot as plt
from copy import copy
from time import sleep

ROOT = (-1, -1, 0, None)
global_index = 0

def olderBrother(T, v, vb):
    p = T.predecessors(v)[0]
    return vb in T.successors(p)

def kConnectedToBranch(G, T, parent, v_cand, k):
    if parent == ROOT:
        return True
    neighbors = [x[1] for x in G.edges(v_cand)]
    # print parent, v_cand, neighbors
    count = 0 if parent[1] in neighbors else 1
    while T.predecessors(parent) != [ROOT]:
        parent = T.predecessors(parent)[0]
        # print parent, v_cand, neighbors
        count += not parent[1] in neighbors
    # print count
    return count < k

# Creates an auxiliary tree used to find k-plexes
# G - Given graph
# T - empty tree
# candidates - all nodes
def kplexTree(G, T, candidates, k, parent = ROOT, degree = -1, ind = 0):
    if candidates == {}:
        return ind
    candidates_orig = copy(candidates)
    # print "parent {}. Candidates: {}. degree: {}".format(parent, candidates, degree)
    for v_cand in candidates_orig:
        if kConnectedToBranch(G, T, parent, v_cand, k):
            ind += 1
            newLeaf = (degree+1, v_cand, ind)
            T.add_node(newLeaf)
            T.add_edge(parent, newLeaf)
    succList = T.successors(parent)
    # print "created leaves: {}".format(succList)
    newCandidates = {x[1] for x in succList}
    for node in succList:
        newCandidates -= {node[1]}
        # print "new siblings = {} sent to node {}".format(newCandidates, node)
        ind = kplexTree(G, T, newCandidates, k, node, degree+1, ind)
    return ind


def kplexFromLeaf(T, leaf):
    if leaf == ROOT:
        return set()
    # print leaf
    res = kplexFromLeaf(T, T.predecessors(leaf)[0])
    res.add(leaf[1])
    return res


# Extract k-plexes from the tree generated by the function kplexTree
def kplexesFromTree(T, node = ROOT):
    succ = T.successors(node)
    if succ == []:
        kplex = kplexFromLeaf(T, node)
        return [kplex]
    kplexes = []
    for v in succ:
        kplexes.extend(kplexesFromTree(T, v))
    return kplexes


def getMaximalSets(S):
    sortedSets = sorted(S, key = len)
    sortedSets = filter(lambda x: len(x)>2, sortedSets)
    maximalSets = []
    N = len(sortedSets)
    for i in range(N):
        for i2 in range(N-1, -1, -1):
            if len(sortedSets[i]) >= len(sortedSets[i2]):
                maximalSets.append(sortedSets[i])
                break
            if sortedSets[i].issubset(sortedSets[i2]):
                break
    return maximalSets

def getMaximalSetsV1(S):
    S_copy = copy(S)
    for s in S:
        for s2 in S_copy:
            if len(s) >= len(s2):
                continue
            if s.issubset(s2):
                # print "removing", s, s2
                S_copy.remove(s)
                break
    return S_copy


def kplexAlg(G, k, verbose=False):
    tree = nx.DiGraph()
    tree.add_node(ROOT)
    candidates = G.nodes()

    if verbose:
        print "Building auxiliary tree..."
    kplexTree(G, tree, candidates, k)
    if verbose:
        print "Done Building auxiliary tree"
        print "Reading all kplexes..."
    kplexFull = kplexesFromTree(tree)
    if verbose:
        print "Done Reading all kplexes"
        print "Getting maximal kplexes..."
    kplexMax = getMaximalSets(kplexFull)
    if verbose:
        print "Done Getting maximal kplexes"
    return kplexFull, kplexMax


if __name__ == "__main__":

    networkFile = "smallExamples/net20_30.net"
    # G = nx.read_pajek(networkFile)
    # G = nx.fast_gnp_random_graph(20, 0.2)

    G = nx.Graph({
        0: {1,2},
        1: {0, 4,5},
        2: {3,4,0},
        3: {2,4,5},
        4: {1,2,3},
        5: {1,2,3}
    })


    pos=nx.spring_layout(G) # positions for all nodes

    # nodes
    nx.draw_networkx_nodes(G,pos,node_size=700)

    # edges
    nx.draw_networkx_edges(G,pos, width=3)

    # labels
    nx.draw_networkx_labels(G,pos,font_size=20,font_family='sans-serif')

    plt.axis('off')
    plt.show(block=False)

    N = len(G.nodes())
    print "Nodes: {}".format(G.nodes())

    k = 2
    kplexes, kplexesMax = kplexAlg(G, k)
    print "List of {}-plexes".format(k)
    print kplexes
    print kplexesMax
    plt.figure()

    raw_input("Press <Enter> to continue")

